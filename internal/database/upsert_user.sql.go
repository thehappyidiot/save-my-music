// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: upsert_user.sql

package database

import (
	"context"
	"database/sql"
)

const upsertUser = `-- name: UpsertUser :one
INSERT INTO app.users (
        google_sub,
        email,
        picture_url,
        full_name,
        given_name,
        family_name,
        created_at,
        updated_at
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        NOW(),
        NOW()
    ) ON CONFLICT (google_sub) DO
UPDATE
SET email = $2,
    picture_url = $3,
    full_name = $4,
    given_name = $5,
    family_name = $6,
    updated_at = NOW()
RETURNING id, google_sub, email, picture_url, full_name, given_name, family_name, created_at, updated_at
`

type UpsertUserParams struct {
	GoogleSub  sql.NullString
	Email      sql.NullString
	PictureUrl interface{}
	FullName   sql.NullString
	GivenName  sql.NullString
	FamilyName sql.NullString
}

func (q *Queries) UpsertUser(ctx context.Context, arg UpsertUserParams) (AppUser, error) {
	row := q.db.QueryRowContext(ctx, upsertUser,
		arg.GoogleSub,
		arg.Email,
		arg.PictureUrl,
		arg.FullName,
		arg.GivenName,
		arg.FamilyName,
	)
	var i AppUser
	err := row.Scan(
		&i.ID,
		&i.GoogleSub,
		&i.Email,
		&i.PictureUrl,
		&i.FullName,
		&i.GivenName,
		&i.FamilyName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
